(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{"./src/components/Checkbox/Checkbox.styles.ts":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(t,"__esModule",{value:!0}),t.getCheckboxStyles=t.getCheckboxVariables=void 0;var a=i(n("./node_modules/@babel/runtime/helpers/objectSpread.js")),o=function(e){return{base:{backgroundColor:e.colors.background.white,borderColor:e.colors.border.default,borderWidth:1,height:32,width:32},checked:{backgroundColor:e.colors.background.primaryDefault,borderColor:"transparent"},checkedFocus:{backgroundColor:e.colors.background.primaryDark},disabled:{backgroundColor:e.colors.background.greyDark,borderColor:e.colors.border.default},shape:{circle:{borderRadius:999},square:{borderRadius:e.controlBorderRadius.small}},uncheckedFocus:{backgroundColor:e.colors.background.greyLight}}};t.getCheckboxVariables=o;t.getCheckboxStyles=function(e,t){var n=e.isChecked,i=e.isDisabled,r=e.shape,l=o(t);return{checkboxFocusBackgroundColor:n?l.checkedFocus.backgroundColor:l.uncheckedFocus.backgroundColor,checkboxStyle:(0,a.default)({},l.base,n?l.checked:{},i?l.disabled:{},l.shape[r])}};try{o.displayName="getCheckboxVariables",o.__docgenInfo={description:"",displayName:"getCheckboxVariables",props:{colors:{defaultValue:null,description:"",name:"colors",required:!0,type:{name:"Colors"}},fills:{defaultValue:null,description:"",name:"fills",required:!0,type:{name:"Fills"}},fontFamilies:{defaultValue:null,description:"",name:"fontFamilies",required:!0,type:{name:"FontFamilies"}},fontWeights:{defaultValue:null,description:"",name:"fontWeights",required:!0,type:{name:"FontWeights"}},headingSizes:{defaultValue:null,description:"",name:"headingSizes",required:!0,type:{name:"HeadingSizes"}},paragraphSizes:{defaultValue:null,description:"",name:"paragraphSizes",required:!0,type:{name:"ParagraphSizes"}},textSizes:{defaultValue:null,description:"",name:"textSizes",required:!0,type:{name:"TextSizes"}},elevations:{defaultValue:null,description:"",name:"elevations",required:!0,type:{name:"ViewStyle[]"}},controlPaddings:{defaultValue:null,description:"",name:"controlPaddings",required:!0,type:{name:"ControlSizes"}},controlHeights:{defaultValue:null,description:"",name:"controlHeights",required:!0,type:{name:"ControlSizes"}},controlBorderRadius:{defaultValue:null,description:"",name:"controlBorderRadius",required:!0,type:{name:"ControlSizes"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/Checkbox/Checkbox.styles.ts#getCheckboxVariables"]={docgenInfo:o.__docgenInfo,name:"getCheckboxVariables",path:"src/components/Checkbox/Checkbox.styles.ts#getCheckboxVariables"})}catch(r){}},"./src/components/Checkbox/Checkbox.tsx":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"),a=n("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.Checkbox=void 0;var o=a(n("./node_modules/@babel/runtime/helpers/extends.js")),r=a(n("./node_modules/@babel/runtime/helpers/objectWithoutProperties.js")),l=i(n("./node_modules/react/index.js")),s=n("./node_modules/react-native-web/dist/index.js"),d=n("./src/icons/index.ts"),u=n("./src/theme/index.ts"),c=n("./src/utils/mergeStyles.ts"),h=n("./src/components/Checkbox/Checkbox.styles.ts"),m=(0,u.withTheme)(function(e){var t=e.isChecked,n=void 0!==t&&t,i=e.isDisabled,a=void 0!==i&&i,u=e.isInteractive,m=void 0===u||u,p=e.checkedIcon,f=e.onChange,y=void 0===f?function(){return null}:f,b=e.shape,v=void 0===b?"square":b,g=e.theme,w=e.getStyles,S=e.testID,V=(0,r.default)(e,["isChecked","isDisabled","isInteractive","checkedIcon","onChange","shape","theme","getStyles","testID"]),T=(0,c.mergeStyles)(h.getCheckboxStyles,w)({isChecked:n,isDisabled:a,shape:v},g),q=T.checkboxStyle,C=T.checkboxFocusBackgroundColor;return l.createElement(s.TouchableHighlight,(0,o.default)({accessible:!0,style:q,underlayColor:C},m?{disabled:a,onPress:y}:{disabled:!0},{testID:S},V),l.createElement(s.View,{style:{alignItems:"center",display:"flex",height:"100%",justifyContent:"center"}},n?p||l.createElement(d.Icon,{name:"check",size:20,color:g.colors.text.white}):null))});t.Checkbox=m;var p=m;t.default=p},"./src/components/Checkbox/LabeledCheckbox.tsx":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"),a=n("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.LabeledCheckbox=void 0;var o=a(n("./node_modules/@babel/runtime/helpers/objectWithoutProperties.js")),r=i(n("./node_modules/react/index.js")),l=n("./src/theme/index.ts"),s=a(n("./src/components/Checkbox/Checkbox.tsx")),d=n("./src/components/Layout/index.ts"),u=n("./src/components/Typography/index.ts"),c=(0,l.withTheme)(function(e){var t=e.label,n=e.position,i=void 0===n?"right":n,a=e.color,l=e.size,c=(0,o.default)(e,["label","position","color","size"]);return t?r.createElement(d.Box,{flexDirection:"row",alignItems:"center"},"left"===i&&r.createElement(u.Text,{size:l,color:a},t),r.createElement(d.Spacing,{paddingHorizontal:1},r.createElement(s.default,c)),"right"===i&&r.createElement(u.Text,{size:l,color:a},t)):r.createElement(s.default,c)});t.LabeledCheckbox=c;var h=c;t.default=h},"./src/components/Checkbox/index.ts":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"Checkbox",{enumerable:!0,get:function(){return a.default}}),Object.defineProperty(t,"CheckboxProps",{enumerable:!0,get:function(){return a.CheckboxProps}}),Object.defineProperty(t,"LabeledCheckbox",{enumerable:!0,get:function(){return o.default}}),Object.defineProperty(t,"LabeledCheckboxProps",{enumerable:!0,get:function(){return o.LabeledCheckboxProps}});var a=i(n("./src/components/Checkbox/Checkbox.tsx")),o=i(n("./src/components/Checkbox/LabeledCheckbox.tsx"))},"./src/components/ListItem/ListItem.styles.ts":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(t,"__esModule",{value:!0}),t.getListItemStyles=t.getListItemVariables=void 0;var a=i(n("./node_modules/@babel/runtime/helpers/objectSpread.js")),o=i(n("./node_modules/@babel/runtime/helpers/objectWithoutProperties.js")),r=function(e){return{base:{backgroundColor:e.colors.background.white,borderBottomWidth:1,borderColor:e.colors.border.default,justifyContent:"center"},disabled:{backgroundColor:e.colors.background.greyDark},focusBackgroundColor:e.colors.background.greyLight,selected:{},sizes:{small:{fontSize:e.textSizes.small.fontSize||14,height:e.controlHeights.small,paddingLeft:e.controlPaddings.small,paddingRight:e.controlPaddings.small},medium:{fontSize:e.textSizes.medium.fontSize||16,height:e.controlHeights.medium,paddingLeft:e.controlPaddings.medium,paddingRight:e.controlPaddings.medium},large:{fontSize:e.textSizes.large.fontSize||18,height:e.controlHeights.large,paddingLeft:e.controlPaddings.large,paddingRight:e.controlPaddings.large}},wrapper:{alignItems:"center",flexDirection:"row",justifyContent:"space-between"}}};t.getListItemVariables=r;t.getListItemStyles=function(e,t){var n=e.size,i=e.isDisabled,l=e.isSelected,s=r(t),d=s.base,u=s.disabled,c=s.selected,h=s.focusBackgroundColor,m=s.sizes[n],p=(m.fontSize,(0,o.default)(m,["fontSize"]));return{containerStyle:(0,a.default)({},d,p,l?c:{},i?u:{}),focusBackgroundColor:h,imageWrapperStyle:{marginRight:8},leftWrapperStyle:{alignItems:"center",flexDirection:"row"},textStyle:t.textSizes[n],textWrapperStyle:{height:"100%"},wrapperStyle:s.wrapper}};try{r.displayName="getListItemVariables",r.__docgenInfo={description:"",displayName:"getListItemVariables",props:{colors:{defaultValue:null,description:"",name:"colors",required:!0,type:{name:"Colors"}},fills:{defaultValue:null,description:"",name:"fills",required:!0,type:{name:"Fills"}},fontFamilies:{defaultValue:null,description:"",name:"fontFamilies",required:!0,type:{name:"FontFamilies"}},fontWeights:{defaultValue:null,description:"",name:"fontWeights",required:!0,type:{name:"FontWeights"}},headingSizes:{defaultValue:null,description:"",name:"headingSizes",required:!0,type:{name:"HeadingSizes"}},paragraphSizes:{defaultValue:null,description:"",name:"paragraphSizes",required:!0,type:{name:"ParagraphSizes"}},textSizes:{defaultValue:null,description:"",name:"textSizes",required:!0,type:{name:"TextSizes"}},elevations:{defaultValue:null,description:"",name:"elevations",required:!0,type:{name:"ViewStyle[]"}},controlPaddings:{defaultValue:null,description:"",name:"controlPaddings",required:!0,type:{name:"ControlSizes"}},controlHeights:{defaultValue:null,description:"",name:"controlHeights",required:!0,type:{name:"ControlSizes"}},controlBorderRadius:{defaultValue:null,description:"",name:"controlBorderRadius",required:!0,type:{name:"ControlSizes"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/ListItem/ListItem.styles.ts#getListItemVariables"]={docgenInfo:r.__docgenInfo,name:"getListItemVariables",path:"src/components/ListItem/ListItem.styles.ts#getListItemVariables"})}catch(l){}},"./src/components/ListItem/ListItem.tsx":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"),a=n("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var o=a(n("./node_modules/@babel/runtime/helpers/extends.js")),r=a(n("./node_modules/@babel/runtime/helpers/objectWithoutProperties.js")),l=i(n("./node_modules/react/index.js")),s=n("./node_modules/react-native-web/dist/index.js"),d=n("./src/theme/index.ts"),u=n("./src/utils/mergeStyles.ts"),c=n("./src/components/Typography/index.ts"),h=n("./src/components/ListItem/ListItem.styles.ts"),m=function(e){var t=e.getStyles,n=e.isDisabled,i=void 0!==n&&n,a=e.label,m=e.description,p=e.size,f=void 0===p?"medium":p,y=e.onPress,b=e.rightIcon,v=void 0===b?null:b,g=e.leftIcon,w=e.testID,S=(0,r.default)(e,["getStyles","isDisabled","label","description","size","onPress","rightIcon","leftIcon","testID"]),V=l.useContext(d.ThemeContext),T=(0,u.mergeStyles)(h.getListItemStyles,t)({size:f,isDisabled:i},V),q=T.imageWrapperStyle,C=T.leftWrapperStyle,R=T.textWrapperStyle,x=T.containerStyle,k=T.textStyle,I=T.focusBackgroundColor,E=T.wrapperStyle;return l.createElement(s.TouchableHighlight,(0,o.default)({disabled:i,underlayColor:I,style:x,testID:w,onPress:y},S),l.createElement(s.View,{style:E},l.createElement(s.View,{style:C},l.createElement(s.View,{style:q},g),l.createElement(s.View,{style:R},l.createElement(c.Text,{getStyles:function(){return{textStyle:k}}},a),l.createElement(c.Text,{size:"small"},m))),v))},p=m;t.default=p;try{m.displayName="ListItem",m.__docgenInfo={description:"",displayName:"ListItem",props:{size:{defaultValue:null,description:"",name:"size",required:!1,type:{name:'"small" | "medium" | "large"'}},isDisabled:{defaultValue:null,description:"",name:"isDisabled",required:!1,type:{name:"boolean"}},label:{defaultValue:null,description:"",name:"label",required:!0,type:{name:"string"}},description:{defaultValue:null,description:"",name:"description",required:!1,type:{name:"string"}},avatarProps:{defaultValue:null,description:"",name:"avatarProps",required:!1,type:{name:"any"}},leftIcon:{defaultValue:null,description:"",name:"leftIcon",required:!1,type:{name:"ReactNode"}},rightIcon:{defaultValue:null,description:"",name:"rightIcon",required:!1,type:{name:"ReactNode"}},onPress:{defaultValue:null,description:"",name:"onPress",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},getStyles:{defaultValue:null,description:"",name:"getStyles",required:!1,type:{name:"ReplaceReturnType<GetListItemStyles, DeepPartial<ListItemStyles>>"}},testID:{defaultValue:null,description:"",name:"testID",required:!1,type:{name:"string"}},accessible:{defaultValue:null,description:"When true, indicates that the view is an accessibility element.\nBy default, all the touchable elements are accessible.",name:"accessible",required:!1,type:{name:"boolean"}},accessibilityLabel:{defaultValue:null,description:"Overrides the text that's read by the screen reader when the user interacts with the element. By default, the\nlabel is constructed by traversing all the children and accumulating all the Text nodes separated by space.",name:"accessibilityLabel",required:!1,type:{name:"string"}},accessibilityRole:{defaultValue:null,description:"Accessibility Role tells a person using either VoiceOver on iOS or TalkBack on Android the type of element that is focused on.",name:"accessibilityRole",required:!1,type:{name:"AccessibilityRole"}},accessibilityStates:{defaultValue:null,description:"Accessibility State tells a person using either VoiceOver on iOS or TalkBack on Android the state of the element currently focused on.",name:"accessibilityStates",required:!1,type:{name:"AccessibilityState[]"}},accessibilityHint:{defaultValue:null,description:"An accessibility hint helps users understand what will happen when they perform an action on the accessibility element when that result is not obvious from the accessibility label.",name:"accessibilityHint",required:!1,type:{name:"string"}},accessibilityComponentType:{defaultValue:null,description:"In some cases, we also want to alert the end user of the type of selected component (i.e., that it is a \u201cbutton\u201d).\nIf we were using native buttons, this would work automatically. Since we are using javascript, we need to\nprovide a bit more context for TalkBack. To do so, you must specify the \u2018accessibilityComponentType\u2019 property\nfor any UI component. For instances, we support \u2018button\u2019, \u2018radiobutton_checked\u2019 and \u2018radiobutton_unchecked\u2019 and so on.\n@platform android",name:"accessibilityComponentType",required:!1,type:{name:'"none" | "button" | "radiobutton_checked" | "radiobutton_unchecked"'}},accessibilityLiveRegion:{defaultValue:null,description:"Indicates to accessibility services whether the user should be notified when this view changes.\nWorks for Android API >= 19 only.\nSee http://developer.android.com/reference/android/view/View.html#attr_android:accessibilityLiveRegion for references.\n@platform android",name:"accessibilityLiveRegion",required:!1,type:{name:'"none" | "polite" | "assertive"'}},importantForAccessibility:{defaultValue:null,description:"Controls how view is important for accessibility which is if it fires accessibility events\nand if it is reported to accessibility services that query the screen.\nWorks for Android only. See http://developer.android.com/reference/android/R.attr.html#importantForAccessibility for references.\n\nPossible values:\n      'auto' - The system determines whether the view is important for accessibility - default (recommended).\n      'yes' - The view is important for accessibility.\n      'no' - The view is not important for accessibility.\n      'no-hide-descendants' - The view is not important for accessibility, nor are any of its descendant views.",name:"importantForAccessibility",required:!1,type:{name:'"auto" | "yes" | "no" | "no-hide-descendants"'}},accessibilityElementsHidden:{defaultValue:null,description:"A Boolean value indicating whether the accessibility elements contained within this accessibility element\nare hidden to the screen reader.\n@platform ios",name:"accessibilityElementsHidden",required:!1,type:{name:"boolean"}},accessibilityTraits:{defaultValue:null,description:"Accessibility traits tell a person using VoiceOver what kind of element they have selected.\nIs this element a label? A button? A header? These questions are answered by accessibilityTraits.\n@platform ios",name:"accessibilityTraits",required:!1,type:{name:'"none" | "button" | "link" | "search" | "image" | "text" | "adjustable" | "header" | "summary" | "selected" | "disabled" | "plays" | "key" | "frequentUpdates" | "startsMedia" | "allowsDirectInteraction" | "pageTurn" | AccessibilityTrait[]'}},onAccessibilityTap:{defaultValue:null,description:"When `accessible` is true, the system will try to invoke this function when the user performs accessibility tap gesture.\n@platform ios",name:"onAccessibilityTap",required:!1,type:{name:"() => void"}},onMagicTap:{defaultValue:null,description:"When accessible is true, the system will invoke this function when the user performs the magic tap gesture.\n@platform ios",name:"onMagicTap",required:!1,type:{name:"() => void"}},accessibilityIgnoresInvertColors:{defaultValue:null,description:"https://facebook.github.io/react-native/docs/accessibility#accessibilityignoresinvertcolorsios\n@platform ios",name:"accessibilityIgnoresInvertColors",required:!1,type:{name:"boolean"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/ListItem/ListItem.tsx#ListItem"]={docgenInfo:m.__docgenInfo,name:"ListItem",path:"src/components/ListItem/ListItem.tsx#ListItem"})}catch(f){}},"./src/components/ListItem/index.ts":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"ListItem",{enumerable:!0,get:function(){return a.default}}),Object.defineProperty(t,"ListItemProps",{enumerable:!0,get:function(){return a.ListItemProps}});var a=i(n("./src/components/ListItem/ListItem.tsx"))},"./src/components/SelectList/SelectList.tsx":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"),a=n("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.SelectList=void 0;var o=a(n("./node_modules/@babel/runtime/helpers/extends.js")),r=a(n("./node_modules/@babel/runtime/helpers/objectWithoutProperties.js")),l=i(n("./node_modules/react/index.js")),s=n("./node_modules/react-native-web/dist/index.js"),d=n("./src/theme/index.ts"),u=function(e){var t=e.selectedValue,n=e.onValueChange,i=e.isMulti,a=e.children,u=e.innerRef,c=(0,r.default)(e,["selectedValue","onValueChange","isMulti","children","innerRef"]),h=l.useContext(d.ThemeContext),m=function(e,a,o){i&&Array.isArray(t)?n(o?t.filter(function(t){return t!==e}):t.concat(e),a):n(e,a)},p=l.Children.toArray(a),f=p.map(function(e){return e.props});return l.createElement(s.FlatList,(0,o.default)({ref:u,keyExtractor:function(e){return e.value},getItemLayout:function(e,t){return{index:t,length:h.controlHeights.medium,offset:h.controlHeights.medium*t}},data:f,renderItem:function(e){var n=e.item,a=e.index,o=p[a],r=i&&Array.isArray(t)?t.some(function(e){return e===n.value}):t===n.value;return l.cloneElement(o,{index:a,isSelected:r,onSelect:m})}},c))},c=l.forwardRef(function(e,t){return l.createElement(u,(0,o.default)({},e,{innerRef:t}))});t.SelectList=c;var h=c;t.default=h;try{c.displayName="SelectList",c.__docgenInfo={description:"",displayName:"SelectList",props:{selectedValue:{defaultValue:null,description:"",name:"selectedValue",required:!0,type:{name:"string | string[]"}},innerRef:{defaultValue:null,description:"",name:"innerRef",required:!1,type:{name:"Ref<FlatList<any>>"}},isMulti:{defaultValue:null,description:"",name:"isMulti",required:!1,type:{name:"boolean"}},onValueChange:{defaultValue:null,description:"",name:"onValueChange",required:!0,type:{name:"(itemValue: string | string[], itemIndex: number) => void"}},ItemSeparatorComponent:{defaultValue:null,description:"Rendered in between each item, but not at the top or bottom",name:"ItemSeparatorComponent",required:!1,type:{name:"ComponentType<any>"}},ListEmptyComponent:{defaultValue:null,description:"Rendered when the list is empty.",name:"ListEmptyComponent",required:!1,type:{name:"ComponentClass<any, any> | FunctionComponent<any> | ReactElement<any, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<...>)>"}},ListFooterComponent:{defaultValue:null,description:"Rendered at the very end of the list.",name:"ListFooterComponent",required:!1,type:{name:"ComponentClass<any, any> | FunctionComponent<any> | ReactElement<any, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<...>)>"}},ListHeaderComponent:{defaultValue:null,description:"Rendered at the very beginning of the list.",name:"ListHeaderComponent",required:!1,type:{name:"ComponentClass<any, any> | FunctionComponent<any> | ReactElement<any, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<...>)>"}},columnWrapperStyle:{defaultValue:null,description:"Optional custom style for multi-item rows generated when numColumns > 1",name:"columnWrapperStyle",required:!1,type:{name:"StyleProp<ViewStyle>"}},keyboardShouldPersistTaps:{defaultValue:null,description:"When false tapping outside of the focused text input when the keyboard\nis up dismisses the keyboard. When true the scroll view will not catch\ntaps and the keyboard will not dismiss automatically. The default value\nis false.",name:"keyboardShouldPersistTaps",required:!1,type:{name:'boolean | "always" | "never" | "handled"'}},extraData:{defaultValue:null,description:"A marker property for telling the list to re-render (since it implements PureComponent).\nIf any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the `data` prop,\nstick it here and treat it immutably.",name:"extraData",required:!1,type:{name:"any"}},getItemLayout:{defaultValue:null,description:"`getItemLayout` is an optional optimization that lets us skip measurement of dynamic\ncontent if you know the height of items a priori. getItemLayout is the most efficient,\nand is easy to use if you have fixed height items, for example:\n```\n     * getItemLayout={(data, index) => (\n     *   {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}\n     * )}\n     * ```\nRemember to include separator length (height or width) in your offset calculation if you specify\n`ItemSeparatorComponent`.",name:"getItemLayout",required:!1,type:{name:"(data: any[], index: number) => { length: number; offset: number; index: number; }"}},horizontal:{defaultValue:null,description:"If true, renders items next to each other horizontally instead of stacked vertically.",name:"horizontal",required:!1,type:{name:"boolean"}},initialNumToRender:{defaultValue:null,description:"How many items to render in the initial batch",name:"initialNumToRender",required:!1,type:{name:"number"}},initialScrollIndex:{defaultValue:null,description:"Instead of starting at the top with the first item, start at initialScrollIndex",name:"initialScrollIndex",required:!1,type:{name:"number"}},keyExtractor:{defaultValue:null,description:"Used to extract a unique key for a given item at the specified index. Key is used for caching\nand as the react key to track item re-ordering. The default extractor checks `item.key`, then\nfalls back to using the index, like React does.",name:"keyExtractor",required:!1,type:{name:"(item: any, index: number) => string"}},legacyImplementation:{defaultValue:null,description:"Uses legacy MetroListView instead of default VirtualizedSectionList",name:"legacyImplementation",required:!1,type:{name:"boolean"}},numColumns:{defaultValue:null,description:"Multiple columns can only be rendered with `horizontal={false}` and will zig-zag like a `flexWrap` layout.\nItems should all be the same height - masonry layouts are not supported.",name:"numColumns",required:!1,type:{name:"number"}},onEndReached:{defaultValue:null,description:"Called once when the scroll position gets within onEndReachedThreshold of the rendered content.",name:"onEndReached",required:!1,type:{name:"(info: { distanceFromEnd: number; }) => void"}},onEndReachedThreshold:{defaultValue:null,description:"How far from the end (in units of visible length of the list) the bottom edge of the\nlist must be from the end of the content to trigger the `onEndReached` callback.\nThus a value of 0.5 will trigger `onEndReached` when the end of the content is\nwithin half the visible length of the list.",name:"onEndReachedThreshold",required:!1,type:{name:"number"}},onRefresh:{defaultValue:null,description:'If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality.\nMake sure to also set the refreshing prop correctly.',name:"onRefresh",required:!1,type:{name:"() => void"}},onViewableItemsChanged:{defaultValue:null,description:"Called when the viewability of rows changes, as defined by the `viewablePercentThreshold` prop.",name:"onViewableItemsChanged",required:!1,type:{name:"(info: { viewableItems: ViewToken[]; changed: ViewToken[]; }) => void"}},refreshing:{defaultValue:null,description:"Set this true while waiting for new data from a refresh.",name:"refreshing",required:!1,type:{name:"boolean"}},viewabilityConfig:{defaultValue:null,description:"See `ViewabilityHelper` for flow type and further documentation.",name:"viewabilityConfig",required:!1,type:{name:"any"}},removeClippedSubviews:{defaultValue:null,description:"Note: may have bugs (missing content) in some circumstances - use at your own risk.\n\nThis may improve scroll performance for large lists.",name:"removeClippedSubviews",required:!1,type:{name:"boolean"}},debug:{defaultValue:null,description:"`debug` will turn on extra logging and visual overlays to aid with debugging both usage and\nimplementation, but with a significant perf hit.",name:"debug",required:!1,type:{name:"boolean"}},disableVirtualization:{defaultValue:null,description:"DEPRECATED: Virtualization provides significant performance and memory optimizations, but fully\nunmounts react instances that are outside of the render window. You should only need to disable\nthis for debugging purposes.",name:"disableVirtualization",required:!1,type:{name:"boolean"}},getItem:{defaultValue:null,description:"A generic accessor for extracting an item from any sort of data blob.",name:"getItem",required:!1,type:{name:"(data: any, index: number) => any"}},getItemCount:{defaultValue:null,description:"Determines how many items are in the data blob.",name:"getItemCount",required:!1,type:{name:"(data: any) => number"}},inverted:{defaultValue:null,description:"Reverses the direction of scroll. Uses scale transforms of -1.",name:"inverted",required:!1,type:{name:"boolean"}},listKey:{defaultValue:null,description:"",name:"listKey",required:!1,type:{name:"string"}},maxToRenderPerBatch:{defaultValue:null,description:"The maximum number of items to render in each incremental render batch. The more rendered at\nonce, the better the fill rate, but responsiveness my suffer because rendering content may\ninterfere with responding to button taps or other interactions.",name:"maxToRenderPerBatch",required:!1,type:{name:"number"}},onLayout:{defaultValue:null,description:"Invoked on mount and layout changes with\n\n{nativeEvent: { layout: {x, y, width, height}}}.",name:"onLayout",required:!1,type:{name:"(event: LayoutChangeEvent) => void"}},onScrollToIndexFailed:{defaultValue:null,description:"Used to handle failures when scrolling to an index that has not been measured yet.\nRecommended action is to either compute your own offset and `scrollTo` it, or scroll as far\nas possible and then try again after more items have been rendered.",name:"onScrollToIndexFailed",required:!1,type:{name:"(info: { index: number; highestMeasuredFrameIndex: number; averageItemLength: number; }) => void"}},progressViewOffset:{defaultValue:null,description:"Set this when offset is needed for the loading indicator to show correctly.\n@platform android",name:"progressViewOffset",required:!1,type:{name:"number"}},renderScrollComponent:{defaultValue:null,description:"Render a custom scroll component, e.g. with a differently styled `RefreshControl`.",name:"renderScrollComponent",required:!1,type:{name:"(props: ScrollViewProps) => ReactElement<ScrollViewProps, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<any, any, any>)>"}},updateCellsBatchingPeriod:{defaultValue:null,description:"Amount of time between low-pri item render batches, e.g. for rendering items quite a ways off\nscreen. Similar fill rate/responsiveness tradeoff as `maxToRenderPerBatch`.",name:"updateCellsBatchingPeriod",required:!1,type:{name:"number"}},viewabilityConfigCallbackPairs:{defaultValue:null,description:"",name:"viewabilityConfigCallbackPairs",required:!1,type:{name:"ViewabilityConfigCallbackPair[]"}},windowSize:{defaultValue:null,description:"Determines the maximum number of items rendered outside of the visible area, in units of\nvisible lengths. So if your list fills the screen, then `windowSize={21}` (the default) will\nrender the visible screen area plus up to 10 screens above and 10 below the viewport. Reducing\nthis number will reduce memory consumption and may improve performance, but will increase the\nchance that fast scrolling may reveal momentary blank areas of unrendered content.",name:"windowSize",required:!1,type:{name:"number"}},contentContainerStyle:{defaultValue:null,description:"These styles will be applied to the scroll view content container which\nwraps all of the child views. Example:\n\n   return (\n     <ScrollView contentContainerStyle={styles.contentContainer}>\n     </ScrollView>\n   );\n   ...\n   const styles = StyleSheet.create({\n     contentContainer: {\n       paddingVertical: 20\n     }\n   });",name:"contentContainerStyle",required:!1,type:{name:"StyleProp<ViewStyle>"}},invertStickyHeaders:{defaultValue:null,description:"If sticky headers should stick at the bottom instead of the top of the\nScrollView. This is usually used with inverted ScrollViews.",name:"invertStickyHeaders",required:!1,type:{name:"boolean"}},keyboardDismissMode:{defaultValue:null,description:"Determines whether the keyboard gets dismissed in response to a drag.\n   - 'none' (the default) drags do not dismiss the keyboard.\n   - 'onDrag' the keyboard is dismissed when a drag begins.\n   - 'interactive' the keyboard is dismissed interactively with the drag\n     and moves in synchrony with the touch; dragging upwards cancels the\n     dismissal.",name:"keyboardDismissMode",required:!1,type:{name:'"none" | "interactive" | "on-drag"'}},onContentSizeChange:{defaultValue:null,description:"Called when scrollable content view of the ScrollView changes.\nHandler function is passed the content width and content height as parameters: (contentWidth, contentHeight)\nIt's implemented using onLayout handler attached to the content container which this ScrollView renders.",name:"onContentSizeChange",required:!1,type:{name:"(w: number, h: number) => void"}},onScroll:{defaultValue:null,description:"Fires at most once per frame during scrolling.\nThe frequency of the events can be contolled using the scrollEventThrottle prop.",name:"onScroll",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},onScrollBeginDrag:{defaultValue:null,description:"Fires if a user initiates a scroll gesture.",name:"onScrollBeginDrag",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},onScrollEndDrag:{defaultValue:null,description:"Fires when a user has finished scrolling.",name:"onScrollEndDrag",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},onMomentumScrollEnd:{defaultValue:null,description:"Fires when scroll view has finished moving",name:"onMomentumScrollEnd",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},onMomentumScrollBegin:{defaultValue:null,description:"Fires when scroll view has begun moving",name:"onMomentumScrollBegin",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},pagingEnabled:{defaultValue:null,description:"When true the scroll view stops on multiples of the scroll view's size\nwhen scrolling. This can be used for horizontal pagination. The default\nvalue is false.",name:"pagingEnabled",required:!1,type:{name:"boolean"}},scrollEnabled:{defaultValue:null,description:"When false, the content does not scroll. The default value is true",name:"scrollEnabled",required:!1,type:{name:"boolean"}},showsHorizontalScrollIndicator:{defaultValue:null,description:"When true, shows a horizontal scroll indicator.",name:"showsHorizontalScrollIndicator",required:!1,type:{name:"boolean"}},showsVerticalScrollIndicator:{defaultValue:null,description:"When true, shows a vertical scroll indicator.",name:"showsVerticalScrollIndicator",required:!1,type:{name:"boolean"}},style:{defaultValue:null,description:"Style",name:"style",required:!1,type:{name:"StyleProp<ViewStyle>"}},refreshControl:{defaultValue:null,description:"A RefreshControl component, used to provide pull-to-refresh\nfunctionality for the ScrollView.",name:"refreshControl",required:!1,type:{name:"ReactElement<RefreshControlProps, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<any, any, any>)>"}},snapToAlignment:{defaultValue:null,description:"When `snapToInterval` is set, `snapToAlignment` will define the relationship of the the snapping to the scroll view.\n      - `start` (the default) will align the snap at the left (horizontal) or top (vertical)\n      - `center` will align the snap in the center\n      - `end` will align the snap at the right (horizontal) or bottom (vertical)",name:"snapToAlignment",required:!1,type:{name:'"start" | "center" | "end"'}},snapToInterval:{defaultValue:null,description:'When set, causes the scroll view to stop at multiples of the value of `snapToInterval`.\nThis can be used for paginating through children that have lengths smaller than the scroll view.\nUsed in combination with `snapToAlignment` and `decelerationRate="fast"`. Overrides less\nconfigurable `pagingEnabled` prop.',name:"snapToInterval",required:!1,type:{name:"number"}},snapToOffsets:{defaultValue:null,description:'When set, causes the scroll view to stop at the defined offsets. This can be used for\npaginating through variously sized children that have lengths smaller than the scroll view.\nTypically used in combination with `decelerationRate="fast"`. Overrides less configurable\n`pagingEnabled` and `snapToInterval` props.',name:"snapToOffsets",required:!1,type:{name:"number[]"}},snapToStart:{defaultValue:null,description:"Use in conjuction with `snapToOffsets`. By default, the beginning of the list counts as a\nsnap offset. Set `snapToStart` to false to disable this behavior and allow the list to scroll\nfreely between its start and the first `snapToOffsets` offset. The default value is true.",name:"snapToStart",required:!1,type:{name:"boolean"}},snapToEnd:{defaultValue:null,description:"Use in conjuction with `snapToOffsets`. By default, the end of the list counts as a snap\noffset. Set `snapToEnd` to false to disable this behavior and allow the list to scroll freely\nbetween its end and the last `snapToOffsets` offset. The default value is true.",name:"snapToEnd",required:!1,type:{name:"boolean"}},hitSlop:{defaultValue:null,description:"This defines how far a touch event can start away from the view.\nTypical interface guidelines recommend touch targets that are at least\n30 - 40 points/density-independent pixels. If a Touchable view has\na height of 20 the touchable height can be extended to 40 with\nhitSlop={{top: 10, bottom: 10, left: 0, right: 0}}\nNOTE The touch area never extends past the parent view bounds and\nthe Z-index of sibling views always takes precedence if a touch\nhits two overlapping views.",name:"hitSlop",required:!1,type:{name:"Insets"}},pointerEvents:{defaultValue:null,description:"In the absence of auto property, none is much like CSS's none value. box-none is as if you had applied the CSS class:\n\n.box-none {\n   pointer-events: none;\n}\n.box-none * {\n   pointer-events: all;\n}\n\nbox-only is the equivalent of\n\n.box-only {\n   pointer-events: all;\n}\n.box-only * {\n   pointer-events: none;\n}\n\nBut since pointerEvents does not affect layout/appearance, and we are already deviating from the spec by adding additional modes,\nwe opt to not include pointerEvents on style. On some platforms, we would need to implement it as a className anyways. Using style or not is an implementation detail of the platform.",name:"pointerEvents",required:!1,type:{name:'"none" | "box-none" | "box-only" | "auto"'}},testID:{defaultValue:null,description:"Used to locate this view in end-to-end tests.",name:"testID",required:!1,type:{name:"string"}},nativeID:{defaultValue:null,description:"Used to reference react managed views from native code.",name:"nativeID",required:!1,type:{name:"string"}},collapsable:{defaultValue:null,description:"Views that are only used to layout their children or otherwise don't draw anything\nmay be automatically removed from the native hierarchy as an optimization.\nSet this property to false to disable this optimization and ensure that this View exists in the native view hierarchy.",name:"collapsable",required:!1,type:{name:"boolean"}},needsOffscreenAlphaCompositing:{defaultValue:null,description:"Whether this view needs to rendered offscreen and composited with an alpha in order to preserve 100% correct colors and blending behavior.\nThe default (false) falls back to drawing the component and its children\nwith an alpha applied to the paint used to draw each element instead of rendering the full component offscreen and compositing it back with an alpha value.\nThis default may be noticeable and undesired in the case where the View you are setting an opacity on\nhas multiple overlapping elements (e.g. multiple overlapping Views, or text and a background).\n\nRendering offscreen to preserve correct alpha behavior is extremely expensive\nand hard to debug for non-native developers, which is why it is not turned on by default.\nIf you do need to enable this property for an animation,\nconsider combining it with renderToHardwareTextureAndroid if the view contents are static (i.e. it doesn't need to be redrawn each frame).\nIf that property is enabled, this View will be rendered off-screen once,\nsaved in a hardware texture, and then composited onto the screen with an alpha each frame without having to switch rendering targets on the GPU.",name:"needsOffscreenAlphaCompositing",required:!1,type:{name:"boolean"}},renderToHardwareTextureAndroid:{defaultValue:null,description:"Whether this view should render itself (and all of its children) into a single hardware texture on the GPU.\n\nOn Android, this is useful for animations and interactions that only modify opacity, rotation, translation, and/or scale:\nin those cases, the view doesn't have to be redrawn and display lists don't need to be re-executed. The texture can just be\nre-used and re-composited with different parameters. The downside is that this can use up limited video memory, so this prop should be set back to false at the end of the interaction/animation.",name:"renderToHardwareTextureAndroid",required:!1,type:{name:"boolean"}},accessibilityViewIsModal:{defaultValue:null,description:"A Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver.\n@platform ios",name:"accessibilityViewIsModal",required:!1,type:{name:"boolean"}},accessibilityActions:{defaultValue:null,description:"Provides an array of custom actions available for accessibility.\n@platform ios",name:"accessibilityActions",required:!1,type:{name:"string[]"}},onAccessibilityAction:{defaultValue:null,description:"When `accessible` is true, the system will try to invoke this function\nwhen the user performs an accessibility custom action.\n@platform ios",name:"onAccessibilityAction",required:!1,type:{name:"() => void"}},shouldRasterizeIOS:{defaultValue:null,description:"Whether this view should be rendered as a bitmap before compositing.\n\nOn iOS, this is useful for animations and interactions that do not modify this component's dimensions nor its children;\nfor example, when translating the position of a static view, rasterization allows the renderer to reuse a cached bitmap of a static view\nand quickly composite it during each frame.\n\nRasterization incurs an off-screen drawing pass and the bitmap consumes memory.\nTest and measure when using this property.",name:"shouldRasterizeIOS",required:!1,type:{name:"boolean"}},onStartShouldSetResponder:{defaultValue:null,description:"A view can become the touch responder by implementing the correct negotiation methods.\nThere are two methods to ask the view if it wants to become responder:\nDoes this view want to become responder on the start of a touch?",name:"onStartShouldSetResponder",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onMoveShouldSetResponder:{defaultValue:null,description:'Called for every touch move on the View when it is not the responder: does this view want to "claim" touch responsiveness?',name:"onMoveShouldSetResponder",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onResponderEnd:{defaultValue:null,description:"If the View returns true and attempts to become the responder, one of the following will happen:",name:"onResponderEnd",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderGrant:{defaultValue:null,description:"The View is now responding for touch events.\nThis is the time to highlight and show the user what is happening",name:"onResponderGrant",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderReject:{defaultValue:null,description:"Something else is the responder right now and will not release it",name:"onResponderReject",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderMove:{defaultValue:null,description:"If the view is responding, the following handlers can be called:\nThe user is moving their finger",name:"onResponderMove",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderRelease:{defaultValue:null,description:'Fired at the end of the touch, ie "touchUp"',name:"onResponderRelease",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderStart:{defaultValue:null,description:"",name:"onResponderStart",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderTerminationRequest:{defaultValue:null,description:"Something else wants to become responder.\nShould this view release the responder? Returning true allows release",name:"onResponderTerminationRequest",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onResponderTerminate:{defaultValue:null,description:"The responder has been taken from the View.\nMight be taken by other views after a call to onResponderTerminationRequest,\nor might be taken by the OS without asking (happens with control center/ notification center on iOS)",name:"onResponderTerminate",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onStartShouldSetResponderCapture:{defaultValue:null,description:"onStartShouldSetResponder and onMoveShouldSetResponder are called with a bubbling pattern,\nwhere the deepest node is called first.\nThat means that the deepest component will become responder when multiple Views return true for *ShouldSetResponder handlers.\nThis is desirable in most cases, because it makes sure all controls and buttons are usable.\n\nHowever, sometimes a parent will want to make sure that it becomes responder.\nThis can be handled by using the capture phase.\nBefore the responder system bubbles up from the deepest component,\nit will do a capture phase, firing on*ShouldSetResponderCapture.\nSo if a parent View wants to prevent the child from becoming responder on a touch start,\nit should have a onStartShouldSetResponderCapture handler which returns true.",name:"onStartShouldSetResponderCapture",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onMoveShouldSetResponderCapture:{defaultValue:null,description:"onStartShouldSetResponder and onMoveShouldSetResponder are called with a bubbling pattern,\nwhere the deepest node is called first.\nThat means that the deepest component will become responder when multiple Views return true for *ShouldSetResponder handlers.\nThis is desirable in most cases, because it makes sure all controls and buttons are usable.\n\nHowever, sometimes a parent will want to make sure that it becomes responder.\nThis can be handled by using the capture phase.\nBefore the responder system bubbles up from the deepest component,\nit will do a capture phase, firing on*ShouldSetResponderCapture.\nSo if a parent View wants to prevent the child from becoming responder on a touch start,\nit should have a onStartShouldSetResponderCapture handler which returns true.",name:"onMoveShouldSetResponderCapture",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onTouchStart:{defaultValue:null,description:"",name:"onTouchStart",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onTouchMove:{defaultValue:null,description:"",name:"onTouchMove",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onTouchEnd:{defaultValue:null,description:"",name:"onTouchEnd",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onTouchCancel:{defaultValue:null,description:"",name:"onTouchCancel",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onTouchEndCapture:{defaultValue:null,description:"",name:"onTouchEndCapture",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},accessible:{defaultValue:null,description:"When true, indicates that the view is an accessibility element.\nBy default, all the touchable elements are accessible.",name:"accessible",required:!1,type:{name:"boolean"}},accessibilityLabel:{defaultValue:null,description:"Overrides the text that's read by the screen reader when the user interacts with the element. By default, the\nlabel is constructed by traversing all the children and accumulating all the Text nodes separated by space.",name:"accessibilityLabel",required:!1,type:{name:"string"}},accessibilityRole:{defaultValue:null,description:"Accessibility Role tells a person using either VoiceOver on iOS or TalkBack on Android the type of element that is focused on.",name:"accessibilityRole",required:!1,type:{name:"AccessibilityRole"}},accessibilityStates:{defaultValue:null,description:"Accessibility State tells a person using either VoiceOver on iOS or TalkBack on Android the state of the element currently focused on.",name:"accessibilityStates",required:!1,type:{name:"AccessibilityState[]"}},accessibilityHint:{defaultValue:null,description:"An accessibility hint helps users understand what will happen when they perform an action on the accessibility element when that result is not obvious from the accessibility label.",name:"accessibilityHint",required:!1,type:{name:"string"}},accessibilityComponentType:{defaultValue:null,description:"In some cases, we also want to alert the end user of the type of selected component (i.e., that it is a \u201cbutton\u201d).\nIf we were using native buttons, this would work automatically. Since we are using javascript, we need to\nprovide a bit more context for TalkBack. To do so, you must specify the \u2018accessibilityComponentType\u2019 property\nfor any UI component. For instances, we support \u2018button\u2019, \u2018radiobutton_checked\u2019 and \u2018radiobutton_unchecked\u2019 and so on.\n@platform android",name:"accessibilityComponentType",required:!1,type:{name:'"none" | "button" | "radiobutton_checked" | "radiobutton_unchecked"'}},accessibilityLiveRegion:{defaultValue:null,description:"Indicates to accessibility services whether the user should be notified when this view changes.\nWorks for Android API >= 19 only.\nSee http://developer.android.com/reference/android/view/View.html#attr_android:accessibilityLiveRegion for references.\n@platform android",name:"accessibilityLiveRegion",required:!1,type:{name:'"none" | "polite" | "assertive"'}},importantForAccessibility:{defaultValue:null,description:"Controls how view is important for accessibility which is if it fires accessibility events\nand if it is reported to accessibility services that query the screen.\nWorks for Android only. See http://developer.android.com/reference/android/R.attr.html#importantForAccessibility for references.\n\nPossible values:\n      'auto' - The system determines whether the view is important for accessibility - default (recommended).\n      'yes' - The view is important for accessibility.\n      'no' - The view is not important for accessibility.\n      'no-hide-descendants' - The view is not important for accessibility, nor are any of its descendant views.",name:"importantForAccessibility",required:!1,type:{name:'"auto" | "yes" | "no" | "no-hide-descendants"'}},accessibilityElementsHidden:{defaultValue:null,description:"A Boolean value indicating whether the accessibility elements contained within this accessibility element\nare hidden to the screen reader.\n@platform ios",name:"accessibilityElementsHidden",required:!1,type:{name:"boolean"}},accessibilityTraits:{defaultValue:null,description:"Accessibility traits tell a person using VoiceOver what kind of element they have selected.\nIs this element a label? A button? A header? These questions are answered by accessibilityTraits.\n@platform ios",name:"accessibilityTraits",required:!1,type:{name:'"none" | "button" | "link" | "search" | "image" | "text" | "adjustable" | "header" | "summary" | "selected" | "disabled" | "plays" | "key" | "frequentUpdates" | "startsMedia" | "allowsDirectInteraction" | "pageTurn" | AccessibilityTrait[]'}},onAccessibilityTap:{defaultValue:null,description:"When `accessible` is true, the system will try to invoke this function when the user performs accessibility tap gesture.\n@platform ios",name:"onAccessibilityTap",required:!1,type:{name:"() => void"}},onMagicTap:{defaultValue:null,description:"When accessible is true, the system will invoke this function when the user performs the magic tap gesture.\n@platform ios",name:"onMagicTap",required:!1,type:{name:"() => void"}},accessibilityIgnoresInvertColors:{defaultValue:null,description:"https://facebook.github.io/react-native/docs/accessibility#accessibilityignoresinvertcolorsios\n@platform ios",name:"accessibilityIgnoresInvertColors",required:!1,type:{name:"boolean"}},alwaysBounceHorizontal:{defaultValue:null,description:"When true the scroll view bounces horizontally when it reaches the end\neven if the content is smaller than the scroll view itself. The default\nvalue is true when `horizontal={true}` and false otherwise.",name:"alwaysBounceHorizontal",required:!1,type:{name:"boolean"}},alwaysBounceVertical:{defaultValue:null,description:"When true the scroll view bounces vertically when it reaches the end\neven if the content is smaller than the scroll view itself. The default\nvalue is false when `horizontal={true}` and true otherwise.",name:"alwaysBounceVertical",required:!1,type:{name:"boolean"}},automaticallyAdjustContentInsets:{defaultValue:null,description:"Controls whether iOS should automatically adjust the content inset for scroll views that are placed behind a navigation bar or tab bar/ toolbar.\nThe default value is true.",name:"automaticallyAdjustContentInsets",required:!1,type:{name:"boolean"}},bounces:{defaultValue:null,description:"When true the scroll view bounces when it reaches the end of the\ncontent if the content is larger then the scroll view along the axis of\nthe scroll direction. When false it disables all bouncing even if\nthe `alwaysBounce*` props are true. The default value is true.",name:"bounces",required:!1,type:{name:"boolean"}},bouncesZoom:{defaultValue:null,description:"When true gestures can drive zoom past min/max and the zoom will animate\nto the min/max value at gesture end otherwise the zoom will not exceed\nthe limits.",name:"bouncesZoom",required:!1,type:{name:"boolean"}},canCancelContentTouches:{defaultValue:null,description:"When false once tracking starts won't try to drag if the touch moves.\nThe default value is true.",name:"canCancelContentTouches",required:!1,type:{name:"boolean"}},centerContent:{defaultValue:null,description:"When true the scroll view automatically centers the content when the\ncontent is smaller than the scroll view bounds; when the content is\nlarger than the scroll view this property has no effect. The default\nvalue is false.",name:"centerContent",required:!1,type:{name:"boolean"}},contentInset:{defaultValue:null,description:"The amount by which the scroll view content is inset from the edges of the scroll view.\nDefaults to {0, 0, 0, 0}.",name:"contentInset",required:!1,type:{name:"Insets"}},contentOffset:{defaultValue:null,description:"Used to manually set the starting scroll offset.\nThe default value is {x: 0, y: 0}",name:"contentOffset",required:!1,type:{name:"PointPropType"}},contentInsetAdjustmentBehavior:{defaultValue:null,description:"This property specifies how the safe area insets are used to modify the content area of the scroll view.\nThe default value of this property must be 'automatic'. But the default value is 'never' until RN@0.51.",name:"contentInsetAdjustmentBehavior",required:!1,type:{name:'"always" | "never" | "automatic" | "scrollableAxes"'}},decelerationRate:{defaultValue:null,description:"A floating-point number that determines how quickly the scroll view\ndecelerates after the user lifts their finger. Reasonable choices include\n   - Normal: 0.998 (the default)\n   - Fast: 0.9",name:"decelerationRate",required:!1,type:{name:'number | "fast" | "normal"'}},directionalLockEnabled:{defaultValue:null,description:"When true the ScrollView will try to lock to only vertical or horizontal\nscrolling while dragging.  The default value is false.",name:"directionalLockEnabled",required:!1,type:{name:"boolean"}},indicatorStyle:{defaultValue:null,description:"The style of the scroll indicators.\n- default (the default), same as black.\n- black, scroll indicator is black. This style is good against\n   a white content background.\n- white, scroll indicator is white. This style is good against\n   a black content background.",name:"indicatorStyle",required:!1,type:{name:'"default" | "black" | "white"'}},maximumZoomScale:{defaultValue:null,description:"The maximum allowed zoom scale. The default value is 1.0.",name:"maximumZoomScale",required:!1,type:{name:"number"}},minimumZoomScale:{defaultValue:null,description:"The minimum allowed zoom scale. The default value is 1.0.",name:"minimumZoomScale",required:!1,type:{name:"number"}},onScrollAnimationEnd:{defaultValue:null,description:"Called when a scrolling animation ends.",name:"onScrollAnimationEnd",required:!1,type:{name:"() => void"}},pinchGestureEnabled:{defaultValue:null,description:"When true, ScrollView allows use of pinch gestures to zoom in and out.\nThe default value is true.",name:"pinchGestureEnabled",required:!1,type:{name:"boolean"}},scrollEventThrottle:{defaultValue:null,description:"This controls how often the scroll event will be fired while scrolling (in events per seconds).\nA higher number yields better accuracy for code that is tracking the scroll position,\nbut can lead to scroll performance problems due to the volume of information being send over the bridge.\nThe default value is zero, which means the scroll event will be sent only once each time the view is scrolled.",name:"scrollEventThrottle",required:!1,type:{name:"number"}},scrollIndicatorInsets:{defaultValue:null,description:"The amount by which the scroll view indicators are inset from the edges of the scroll view.\nThis should normally be set to the same value as the contentInset.\nDefaults to {0, 0, 0, 0}.",name:"scrollIndicatorInsets",required:!1,type:{name:"Insets"}},scrollsToTop:{defaultValue:null,description:"When true the scroll view scrolls to top when the status bar is tapped.\nThe default value is true.",name:"scrollsToTop",required:!1,type:{name:"boolean"}},stickyHeaderIndices:{defaultValue:null,description:"An array of child indices determining which children get docked to the\ntop of the screen when scrolling. For example passing\n`stickyHeaderIndices={[0]}` will cause the first child to be fixed to the\ntop of the scroll view. This property is not supported in conjunction\nwith `horizontal={true}`.",name:"stickyHeaderIndices",required:!1,type:{name:"number[]"}},zoomScale:{defaultValue:null,description:"The current scale of the scroll view content. The default value is 1.0.",name:"zoomScale",required:!1,type:{name:"number"}},endFillColor:{defaultValue:null,description:"Sometimes a scrollview takes up more space than its content fills.\nWhen this is the case, this prop will fill the rest of the\nscrollview with a color to avoid setting a background and creating\nunnecessary overdraw. This is an advanced optimization that is not\nneeded in the general case.",name:"endFillColor",required:!1,type:{name:"string"}},scrollPerfTag:{defaultValue:null,description:"Tag used to log scroll performance on this scroll view. Will force\nmomentum events to be turned on (see sendMomentumEvents). This doesn't do\nanything out of the box and you need to implement a custom native\nFpsListener for it to be useful.\n@platform android",name:"scrollPerfTag",required:!1,type:{name:"string"}},overScrollMode:{defaultValue:null,description:"Used to override default value of overScroll mode.\n\n   Possible values:\n     - 'auto' - Default value, allow a user to over-scroll this view only if the content is large enough to meaningfully scroll.\n     - 'always' - Always allow a user to over-scroll this view.\n     - 'never' - Never allow a user to over-scroll this view.",name:"overScrollMode",required:!1,type:{name:'"always" | "never" | "auto"'}},nestedScrollEnabled:{defaultValue:null,description:"Enables nested scrolling for Android API level 21+. Nested scrolling is supported by default on iOS.",name:"nestedScrollEnabled",required:!1,type:{name:"boolean"}},ref:{defaultValue:null,description:"",name:"ref",required:!1,type:{name:"Ref<FlatList<any>>"}},key:{defaultValue:null,description:"",name:"key",required:!1,type:{name:"ReactText"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/SelectList/SelectList.tsx#SelectList"]={docgenInfo:c.__docgenInfo,name:"SelectList",path:"src/components/SelectList/SelectList.tsx#SelectList"})}catch(m){}try{ForwardRefExoticComponent.displayName="ForwardRefExoticComponent",ForwardRefExoticComponent.__docgenInfo={description:"",displayName:"ForwardRefExoticComponent",props:{selectedValue:{defaultValue:null,description:"",name:"selectedValue",required:!0,type:{name:"string | string[]"}},innerRef:{defaultValue:null,description:"",name:"innerRef",required:!1,type:{name:"Ref<FlatList<any>>"}},isMulti:{defaultValue:null,description:"",name:"isMulti",required:!1,type:{name:"boolean"}},onValueChange:{defaultValue:null,description:"",name:"onValueChange",required:!0,type:{name:"(itemValue: string | string[], itemIndex: number) => void"}},ItemSeparatorComponent:{defaultValue:null,description:"Rendered in between each item, but not at the top or bottom",name:"ItemSeparatorComponent",required:!1,type:{name:"ComponentType<any>"}},ListEmptyComponent:{defaultValue:null,description:"Rendered when the list is empty.",name:"ListEmptyComponent",required:!1,type:{name:"ComponentClass<any, any> | FunctionComponent<any> | ReactElement<any, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<...>)>"}},ListFooterComponent:{defaultValue:null,description:"Rendered at the very end of the list.",name:"ListFooterComponent",required:!1,type:{name:"ComponentClass<any, any> | FunctionComponent<any> | ReactElement<any, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<...>)>"}},ListHeaderComponent:{defaultValue:null,description:"Rendered at the very beginning of the list.",name:"ListHeaderComponent",required:!1,type:{name:"ComponentClass<any, any> | FunctionComponent<any> | ReactElement<any, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<...>)>"}},columnWrapperStyle:{defaultValue:null,description:"Optional custom style for multi-item rows generated when numColumns > 1",name:"columnWrapperStyle",required:!1,type:{name:"StyleProp<ViewStyle>"}},keyboardShouldPersistTaps:{defaultValue:null,description:"When false tapping outside of the focused text input when the keyboard\nis up dismisses the keyboard. When true the scroll view will not catch\ntaps and the keyboard will not dismiss automatically. The default value\nis false.",name:"keyboardShouldPersistTaps",required:!1,type:{name:'boolean | "always" | "never" | "handled"'}},extraData:{defaultValue:null,description:"A marker property for telling the list to re-render (since it implements PureComponent).\nIf any of your `renderItem`, Header, Footer, etc. functions depend on anything outside of the `data` prop,\nstick it here and treat it immutably.",name:"extraData",required:!1,type:{name:"any"}},getItemLayout:{defaultValue:null,description:"`getItemLayout` is an optional optimization that lets us skip measurement of dynamic\ncontent if you know the height of items a priori. getItemLayout is the most efficient,\nand is easy to use if you have fixed height items, for example:\n```\n     * getItemLayout={(data, index) => (\n     *   {length: ITEM_HEIGHT, offset: ITEM_HEIGHT * index, index}\n     * )}\n     * ```\nRemember to include separator length (height or width) in your offset calculation if you specify\n`ItemSeparatorComponent`.",name:"getItemLayout",required:!1,type:{name:"(data: any[], index: number) => { length: number; offset: number; index: number; }"}},horizontal:{defaultValue:null,description:"If true, renders items next to each other horizontally instead of stacked vertically.",name:"horizontal",required:!1,type:{name:"boolean"}},initialNumToRender:{defaultValue:null,description:"How many items to render in the initial batch",name:"initialNumToRender",required:!1,type:{name:"number"}},initialScrollIndex:{defaultValue:null,description:"Instead of starting at the top with the first item, start at initialScrollIndex",name:"initialScrollIndex",required:!1,type:{name:"number"}},keyExtractor:{defaultValue:null,description:"Used to extract a unique key for a given item at the specified index. Key is used for caching\nand as the react key to track item re-ordering. The default extractor checks `item.key`, then\nfalls back to using the index, like React does.",name:"keyExtractor",required:!1,type:{name:"(item: any, index: number) => string"}},legacyImplementation:{defaultValue:null,description:"Uses legacy MetroListView instead of default VirtualizedSectionList",name:"legacyImplementation",required:!1,type:{name:"boolean"}},numColumns:{defaultValue:null,description:"Multiple columns can only be rendered with `horizontal={false}` and will zig-zag like a `flexWrap` layout.\nItems should all be the same height - masonry layouts are not supported.",name:"numColumns",required:!1,type:{name:"number"}},onEndReached:{defaultValue:null,description:"Called once when the scroll position gets within onEndReachedThreshold of the rendered content.",name:"onEndReached",required:!1,type:{name:"(info: { distanceFromEnd: number; }) => void"}},onEndReachedThreshold:{defaultValue:null,description:"How far from the end (in units of visible length of the list) the bottom edge of the\nlist must be from the end of the content to trigger the `onEndReached` callback.\nThus a value of 0.5 will trigger `onEndReached` when the end of the content is\nwithin half the visible length of the list.",name:"onEndReachedThreshold",required:!1,type:{name:"number"}},onRefresh:{defaultValue:null,description:'If provided, a standard RefreshControl will be added for "Pull to Refresh" functionality.\nMake sure to also set the refreshing prop correctly.',name:"onRefresh",required:!1,type:{name:"() => void"}},onViewableItemsChanged:{defaultValue:null,description:"Called when the viewability of rows changes, as defined by the `viewablePercentThreshold` prop.",name:"onViewableItemsChanged",required:!1,type:{name:"(info: { viewableItems: ViewToken[]; changed: ViewToken[]; }) => void"}},refreshing:{defaultValue:null,description:"Set this true while waiting for new data from a refresh.",name:"refreshing",required:!1,type:{name:"boolean"}},viewabilityConfig:{defaultValue:null,description:"See `ViewabilityHelper` for flow type and further documentation.",name:"viewabilityConfig",required:!1,type:{name:"any"}},removeClippedSubviews:{defaultValue:null,description:"Note: may have bugs (missing content) in some circumstances - use at your own risk.\n\nThis may improve scroll performance for large lists.",name:"removeClippedSubviews",required:!1,type:{name:"boolean"}},debug:{defaultValue:null,description:"`debug` will turn on extra logging and visual overlays to aid with debugging both usage and\nimplementation, but with a significant perf hit.",name:"debug",required:!1,type:{name:"boolean"}},disableVirtualization:{defaultValue:null,description:"DEPRECATED: Virtualization provides significant performance and memory optimizations, but fully\nunmounts react instances that are outside of the render window. You should only need to disable\nthis for debugging purposes.",name:"disableVirtualization",required:!1,type:{name:"boolean"}},getItem:{defaultValue:null,description:"A generic accessor for extracting an item from any sort of data blob.",name:"getItem",required:!1,type:{name:"(data: any, index: number) => any"}},getItemCount:{defaultValue:null,description:"Determines how many items are in the data blob.",name:"getItemCount",required:!1,type:{name:"(data: any) => number"}},inverted:{defaultValue:null,description:"Reverses the direction of scroll. Uses scale transforms of -1.",name:"inverted",required:!1,type:{name:"boolean"}},listKey:{defaultValue:null,description:"",name:"listKey",required:!1,type:{name:"string"}},maxToRenderPerBatch:{defaultValue:null,description:"The maximum number of items to render in each incremental render batch. The more rendered at\nonce, the better the fill rate, but responsiveness my suffer because rendering content may\ninterfere with responding to button taps or other interactions.",name:"maxToRenderPerBatch",required:!1,type:{name:"number"}},onLayout:{defaultValue:null,description:"Invoked on mount and layout changes with\n\n{nativeEvent: { layout: {x, y, width, height}}}.",name:"onLayout",required:!1,type:{name:"(event: LayoutChangeEvent) => void"}},onScrollToIndexFailed:{defaultValue:null,description:"Used to handle failures when scrolling to an index that has not been measured yet.\nRecommended action is to either compute your own offset and `scrollTo` it, or scroll as far\nas possible and then try again after more items have been rendered.",name:"onScrollToIndexFailed",required:!1,type:{name:"(info: { index: number; highestMeasuredFrameIndex: number; averageItemLength: number; }) => void"}},progressViewOffset:{defaultValue:null,description:"Set this when offset is needed for the loading indicator to show correctly.\n@platform android",name:"progressViewOffset",required:!1,type:{name:"number"}},renderScrollComponent:{defaultValue:null,description:"Render a custom scroll component, e.g. with a differently styled `RefreshControl`.",name:"renderScrollComponent",required:!1,type:{name:"(props: ScrollViewProps) => ReactElement<ScrollViewProps, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<any, any, any>)>"}},updateCellsBatchingPeriod:{defaultValue:null,description:"Amount of time between low-pri item render batches, e.g. for rendering items quite a ways off\nscreen. Similar fill rate/responsiveness tradeoff as `maxToRenderPerBatch`.",name:"updateCellsBatchingPeriod",required:!1,type:{name:"number"}},viewabilityConfigCallbackPairs:{defaultValue:null,description:"",name:"viewabilityConfigCallbackPairs",required:!1,type:{name:"ViewabilityConfigCallbackPair[]"}},windowSize:{defaultValue:null,description:"Determines the maximum number of items rendered outside of the visible area, in units of\nvisible lengths. So if your list fills the screen, then `windowSize={21}` (the default) will\nrender the visible screen area plus up to 10 screens above and 10 below the viewport. Reducing\nthis number will reduce memory consumption and may improve performance, but will increase the\nchance that fast scrolling may reveal momentary blank areas of unrendered content.",name:"windowSize",required:!1,type:{name:"number"}},contentContainerStyle:{defaultValue:null,description:"These styles will be applied to the scroll view content container which\nwraps all of the child views. Example:\n\n   return (\n     <ScrollView contentContainerStyle={styles.contentContainer}>\n     </ScrollView>\n   );\n   ...\n   const styles = StyleSheet.create({\n     contentContainer: {\n       paddingVertical: 20\n     }\n   });",name:"contentContainerStyle",required:!1,type:{name:"StyleProp<ViewStyle>"}},invertStickyHeaders:{defaultValue:null,description:"If sticky headers should stick at the bottom instead of the top of the\nScrollView. This is usually used with inverted ScrollViews.",name:"invertStickyHeaders",required:!1,type:{name:"boolean"}},keyboardDismissMode:{defaultValue:null,description:"Determines whether the keyboard gets dismissed in response to a drag.\n   - 'none' (the default) drags do not dismiss the keyboard.\n   - 'onDrag' the keyboard is dismissed when a drag begins.\n   - 'interactive' the keyboard is dismissed interactively with the drag\n     and moves in synchrony with the touch; dragging upwards cancels the\n     dismissal.",name:"keyboardDismissMode",required:!1,type:{name:'"none" | "interactive" | "on-drag"'}},onContentSizeChange:{defaultValue:null,description:"Called when scrollable content view of the ScrollView changes.\nHandler function is passed the content width and content height as parameters: (contentWidth, contentHeight)\nIt's implemented using onLayout handler attached to the content container which this ScrollView renders.",name:"onContentSizeChange",required:!1,type:{name:"(w: number, h: number) => void"}},onScroll:{defaultValue:null,description:"Fires at most once per frame during scrolling.\nThe frequency of the events can be contolled using the scrollEventThrottle prop.",name:"onScroll",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},onScrollBeginDrag:{defaultValue:null,description:"Fires if a user initiates a scroll gesture.",name:"onScrollBeginDrag",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},onScrollEndDrag:{defaultValue:null,description:"Fires when a user has finished scrolling.",name:"onScrollEndDrag",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},onMomentumScrollEnd:{defaultValue:null,description:"Fires when scroll view has finished moving",name:"onMomentumScrollEnd",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},onMomentumScrollBegin:{defaultValue:null,description:"Fires when scroll view has begun moving",name:"onMomentumScrollBegin",required:!1,type:{name:"(event: NativeSyntheticEvent<NativeScrollEvent>) => void"}},pagingEnabled:{defaultValue:null,description:"When true the scroll view stops on multiples of the scroll view's size\nwhen scrolling. This can be used for horizontal pagination. The default\nvalue is false.",name:"pagingEnabled",required:!1,type:{name:"boolean"}},scrollEnabled:{defaultValue:null,description:"When false, the content does not scroll. The default value is true",name:"scrollEnabled",required:!1,type:{name:"boolean"}},showsHorizontalScrollIndicator:{defaultValue:null,description:"When true, shows a horizontal scroll indicator.",name:"showsHorizontalScrollIndicator",required:!1,type:{name:"boolean"}},showsVerticalScrollIndicator:{defaultValue:null,description:"When true, shows a vertical scroll indicator.",name:"showsVerticalScrollIndicator",required:!1,type:{name:"boolean"}},style:{defaultValue:null,description:"Style",name:"style",required:!1,type:{name:"StyleProp<ViewStyle>"}},refreshControl:{defaultValue:null,description:"A RefreshControl component, used to provide pull-to-refresh\nfunctionality for the ScrollView.",name:"refreshControl",required:!1,type:{name:"ReactElement<RefreshControlProps, string | ((props: any) => ReactElement<any, string | ... | (new (props: any) => Component<any, any, any>)>) | (new (props: any) => Component<any, any, any>)>"}},snapToAlignment:{defaultValue:null,description:"When `snapToInterval` is set, `snapToAlignment` will define the relationship of the the snapping to the scroll view.\n      - `start` (the default) will align the snap at the left (horizontal) or top (vertical)\n      - `center` will align the snap in the center\n      - `end` will align the snap at the right (horizontal) or bottom (vertical)",name:"snapToAlignment",required:!1,type:{name:'"start" | "center" | "end"'}},snapToInterval:{defaultValue:null,description:'When set, causes the scroll view to stop at multiples of the value of `snapToInterval`.\nThis can be used for paginating through children that have lengths smaller than the scroll view.\nUsed in combination with `snapToAlignment` and `decelerationRate="fast"`. Overrides less\nconfigurable `pagingEnabled` prop.',name:"snapToInterval",required:!1,type:{name:"number"}},snapToOffsets:{defaultValue:null,description:'When set, causes the scroll view to stop at the defined offsets. This can be used for\npaginating through variously sized children that have lengths smaller than the scroll view.\nTypically used in combination with `decelerationRate="fast"`. Overrides less configurable\n`pagingEnabled` and `snapToInterval` props.',name:"snapToOffsets",required:!1,type:{name:"number[]"}},snapToStart:{defaultValue:null,description:"Use in conjuction with `snapToOffsets`. By default, the beginning of the list counts as a\nsnap offset. Set `snapToStart` to false to disable this behavior and allow the list to scroll\nfreely between its start and the first `snapToOffsets` offset. The default value is true.",name:"snapToStart",required:!1,type:{name:"boolean"}},snapToEnd:{defaultValue:null,description:"Use in conjuction with `snapToOffsets`. By default, the end of the list counts as a snap\noffset. Set `snapToEnd` to false to disable this behavior and allow the list to scroll freely\nbetween its end and the last `snapToOffsets` offset. The default value is true.",name:"snapToEnd",required:!1,type:{name:"boolean"}},hitSlop:{defaultValue:null,description:"This defines how far a touch event can start away from the view.\nTypical interface guidelines recommend touch targets that are at least\n30 - 40 points/density-independent pixels. If a Touchable view has\na height of 20 the touchable height can be extended to 40 with\nhitSlop={{top: 10, bottom: 10, left: 0, right: 0}}\nNOTE The touch area never extends past the parent view bounds and\nthe Z-index of sibling views always takes precedence if a touch\nhits two overlapping views.",name:"hitSlop",required:!1,type:{name:"Insets"}},pointerEvents:{defaultValue:null,description:"In the absence of auto property, none is much like CSS's none value. box-none is as if you had applied the CSS class:\n\n.box-none {\n   pointer-events: none;\n}\n.box-none * {\n   pointer-events: all;\n}\n\nbox-only is the equivalent of\n\n.box-only {\n   pointer-events: all;\n}\n.box-only * {\n   pointer-events: none;\n}\n\nBut since pointerEvents does not affect layout/appearance, and we are already deviating from the spec by adding additional modes,\nwe opt to not include pointerEvents on style. On some platforms, we would need to implement it as a className anyways. Using style or not is an implementation detail of the platform.",name:"pointerEvents",required:!1,type:{name:'"none" | "box-none" | "box-only" | "auto"'}},testID:{defaultValue:null,description:"Used to locate this view in end-to-end tests.",name:"testID",required:!1,type:{name:"string"}},nativeID:{defaultValue:null,description:"Used to reference react managed views from native code.",name:"nativeID",required:!1,type:{name:"string"}},collapsable:{defaultValue:null,description:"Views that are only used to layout their children or otherwise don't draw anything\nmay be automatically removed from the native hierarchy as an optimization.\nSet this property to false to disable this optimization and ensure that this View exists in the native view hierarchy.",name:"collapsable",required:!1,type:{name:"boolean"}},needsOffscreenAlphaCompositing:{defaultValue:null,description:"Whether this view needs to rendered offscreen and composited with an alpha in order to preserve 100% correct colors and blending behavior.\nThe default (false) falls back to drawing the component and its children\nwith an alpha applied to the paint used to draw each element instead of rendering the full component offscreen and compositing it back with an alpha value.\nThis default may be noticeable and undesired in the case where the View you are setting an opacity on\nhas multiple overlapping elements (e.g. multiple overlapping Views, or text and a background).\n\nRendering offscreen to preserve correct alpha behavior is extremely expensive\nand hard to debug for non-native developers, which is why it is not turned on by default.\nIf you do need to enable this property for an animation,\nconsider combining it with renderToHardwareTextureAndroid if the view contents are static (i.e. it doesn't need to be redrawn each frame).\nIf that property is enabled, this View will be rendered off-screen once,\nsaved in a hardware texture, and then composited onto the screen with an alpha each frame without having to switch rendering targets on the GPU.",name:"needsOffscreenAlphaCompositing",required:!1,type:{name:"boolean"}},renderToHardwareTextureAndroid:{defaultValue:null,description:"Whether this view should render itself (and all of its children) into a single hardware texture on the GPU.\n\nOn Android, this is useful for animations and interactions that only modify opacity, rotation, translation, and/or scale:\nin those cases, the view doesn't have to be redrawn and display lists don't need to be re-executed. The texture can just be\nre-used and re-composited with different parameters. The downside is that this can use up limited video memory, so this prop should be set back to false at the end of the interaction/animation.",name:"renderToHardwareTextureAndroid",required:!1,type:{name:"boolean"}},accessibilityViewIsModal:{defaultValue:null,description:"A Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver.\n@platform ios",name:"accessibilityViewIsModal",required:!1,type:{name:"boolean"}},accessibilityActions:{defaultValue:null,description:"Provides an array of custom actions available for accessibility.\n@platform ios",name:"accessibilityActions",required:!1,type:{name:"string[]"}},onAccessibilityAction:{defaultValue:null,description:"When `accessible` is true, the system will try to invoke this function\nwhen the user performs an accessibility custom action.\n@platform ios",name:"onAccessibilityAction",required:!1,type:{name:"() => void"}},shouldRasterizeIOS:{defaultValue:null,description:"Whether this view should be rendered as a bitmap before compositing.\n\nOn iOS, this is useful for animations and interactions that do not modify this component's dimensions nor its children;\nfor example, when translating the position of a static view, rasterization allows the renderer to reuse a cached bitmap of a static view\nand quickly composite it during each frame.\n\nRasterization incurs an off-screen drawing pass and the bitmap consumes memory.\nTest and measure when using this property.",name:"shouldRasterizeIOS",required:!1,type:{name:"boolean"}},onStartShouldSetResponder:{defaultValue:null,description:"A view can become the touch responder by implementing the correct negotiation methods.\nThere are two methods to ask the view if it wants to become responder:\nDoes this view want to become responder on the start of a touch?",name:"onStartShouldSetResponder",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onMoveShouldSetResponder:{defaultValue:null,description:'Called for every touch move on the View when it is not the responder: does this view want to "claim" touch responsiveness?',name:"onMoveShouldSetResponder",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onResponderEnd:{defaultValue:null,description:"If the View returns true and attempts to become the responder, one of the following will happen:",name:"onResponderEnd",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderGrant:{defaultValue:null,description:"The View is now responding for touch events.\nThis is the time to highlight and show the user what is happening",name:"onResponderGrant",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderReject:{defaultValue:null,description:"Something else is the responder right now and will not release it",name:"onResponderReject",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderMove:{defaultValue:null,description:"If the view is responding, the following handlers can be called:\nThe user is moving their finger",name:"onResponderMove",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderRelease:{defaultValue:null,description:'Fired at the end of the touch, ie "touchUp"',name:"onResponderRelease",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderStart:{defaultValue:null,description:"",name:"onResponderStart",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onResponderTerminationRequest:{defaultValue:null,description:"Something else wants to become responder.\nShould this view release the responder? Returning true allows release",name:"onResponderTerminationRequest",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onResponderTerminate:{defaultValue:null,description:"The responder has been taken from the View.\nMight be taken by other views after a call to onResponderTerminationRequest,\nor might be taken by the OS without asking (happens with control center/ notification center on iOS)",name:"onResponderTerminate",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onStartShouldSetResponderCapture:{defaultValue:null,description:"onStartShouldSetResponder and onMoveShouldSetResponder are called with a bubbling pattern,\nwhere the deepest node is called first.\nThat means that the deepest component will become responder when multiple Views return true for *ShouldSetResponder handlers.\nThis is desirable in most cases, because it makes sure all controls and buttons are usable.\n\nHowever, sometimes a parent will want to make sure that it becomes responder.\nThis can be handled by using the capture phase.\nBefore the responder system bubbles up from the deepest component,\nit will do a capture phase, firing on*ShouldSetResponderCapture.\nSo if a parent View wants to prevent the child from becoming responder on a touch start,\nit should have a onStartShouldSetResponderCapture handler which returns true.",name:"onStartShouldSetResponderCapture",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onMoveShouldSetResponderCapture:{defaultValue:null,description:"onStartShouldSetResponder and onMoveShouldSetResponder are called with a bubbling pattern,\nwhere the deepest node is called first.\nThat means that the deepest component will become responder when multiple Views return true for *ShouldSetResponder handlers.\nThis is desirable in most cases, because it makes sure all controls and buttons are usable.\n\nHowever, sometimes a parent will want to make sure that it becomes responder.\nThis can be handled by using the capture phase.\nBefore the responder system bubbles up from the deepest component,\nit will do a capture phase, firing on*ShouldSetResponderCapture.\nSo if a parent View wants to prevent the child from becoming responder on a touch start,\nit should have a onStartShouldSetResponderCapture handler which returns true.",name:"onMoveShouldSetResponderCapture",required:!1,type:{name:"(event: GestureResponderEvent) => boolean"}},onTouchStart:{defaultValue:null,description:"",name:"onTouchStart",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onTouchMove:{defaultValue:null,description:"",name:"onTouchMove",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onTouchEnd:{defaultValue:null,description:"",name:"onTouchEnd",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onTouchCancel:{defaultValue:null,description:"",name:"onTouchCancel",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},onTouchEndCapture:{defaultValue:null,description:"",name:"onTouchEndCapture",required:!1,type:{name:"(event: GestureResponderEvent) => void"}},accessible:{defaultValue:null,description:"When true, indicates that the view is an accessibility element.\nBy default, all the touchable elements are accessible.",name:"accessible",required:!1,type:{name:"boolean"}},accessibilityLabel:{defaultValue:null,description:"Overrides the text that's read by the screen reader when the user interacts with the element. By default, the\nlabel is constructed by traversing all the children and accumulating all the Text nodes separated by space.",name:"accessibilityLabel",required:!1,type:{name:"string"}},accessibilityRole:{defaultValue:null,description:"Accessibility Role tells a person using either VoiceOver on iOS or TalkBack on Android the type of element that is focused on.",name:"accessibilityRole",required:!1,type:{name:"AccessibilityRole"}},accessibilityStates:{defaultValue:null,description:"Accessibility State tells a person using either VoiceOver on iOS or TalkBack on Android the state of the element currently focused on.",name:"accessibilityStates",required:!1,type:{name:"AccessibilityState[]"}},accessibilityHint:{defaultValue:null,description:"An accessibility hint helps users understand what will happen when they perform an action on the accessibility element when that result is not obvious from the accessibility label.",name:"accessibilityHint",required:!1,type:{name:"string"}},accessibilityComponentType:{defaultValue:null,description:"In some cases, we also want to alert the end user of the type of selected component (i.e., that it is a \u201cbutton\u201d).\nIf we were using native buttons, this would work automatically. Since we are using javascript, we need to\nprovide a bit more context for TalkBack. To do so, you must specify the \u2018accessibilityComponentType\u2019 property\nfor any UI component. For instances, we support \u2018button\u2019, \u2018radiobutton_checked\u2019 and \u2018radiobutton_unchecked\u2019 and so on.\n@platform android",name:"accessibilityComponentType",required:!1,type:{name:'"none" | "button" | "radiobutton_checked" | "radiobutton_unchecked"'}},accessibilityLiveRegion:{defaultValue:null,description:"Indicates to accessibility services whether the user should be notified when this view changes.\nWorks for Android API >= 19 only.\nSee http://developer.android.com/reference/android/view/View.html#attr_android:accessibilityLiveRegion for references.\n@platform android",name:"accessibilityLiveRegion",required:!1,type:{name:'"none" | "polite" | "assertive"'}},importantForAccessibility:{defaultValue:null,description:"Controls how view is important for accessibility which is if it fires accessibility events\nand if it is reported to accessibility services that query the screen.\nWorks for Android only. See http://developer.android.com/reference/android/R.attr.html#importantForAccessibility for references.\n\nPossible values:\n      'auto' - The system determines whether the view is important for accessibility - default (recommended).\n      'yes' - The view is important for accessibility.\n      'no' - The view is not important for accessibility.\n      'no-hide-descendants' - The view is not important for accessibility, nor are any of its descendant views.",name:"importantForAccessibility",required:!1,type:{name:'"auto" | "yes" | "no" | "no-hide-descendants"'}},accessibilityElementsHidden:{defaultValue:null,description:"A Boolean value indicating whether the accessibility elements contained within this accessibility element\nare hidden to the screen reader.\n@platform ios",name:"accessibilityElementsHidden",required:!1,type:{name:"boolean"}},accessibilityTraits:{defaultValue:null,description:"Accessibility traits tell a person using VoiceOver what kind of element they have selected.\nIs this element a label? A button? A header? These questions are answered by accessibilityTraits.\n@platform ios",name:"accessibilityTraits",required:!1,type:{name:'"none" | "button" | "link" | "search" | "image" | "text" | "adjustable" | "header" | "summary" | "selected" | "disabled" | "plays" | "key" | "frequentUpdates" | "startsMedia" | "allowsDirectInteraction" | "pageTurn" | AccessibilityTrait[]'}},onAccessibilityTap:{defaultValue:null,description:"When `accessible` is true, the system will try to invoke this function when the user performs accessibility tap gesture.\n@platform ios",name:"onAccessibilityTap",required:!1,type:{name:"() => void"}},onMagicTap:{defaultValue:null,description:"When accessible is true, the system will invoke this function when the user performs the magic tap gesture.\n@platform ios",name:"onMagicTap",required:!1,type:{name:"() => void"}},accessibilityIgnoresInvertColors:{defaultValue:null,description:"https://facebook.github.io/react-native/docs/accessibility#accessibilityignoresinvertcolorsios\n@platform ios",name:"accessibilityIgnoresInvertColors",required:!1,type:{name:"boolean"}},alwaysBounceHorizontal:{defaultValue:null,description:"When true the scroll view bounces horizontally when it reaches the end\neven if the content is smaller than the scroll view itself. The default\nvalue is true when `horizontal={true}` and false otherwise.",name:"alwaysBounceHorizontal",required:!1,type:{name:"boolean"}},alwaysBounceVertical:{defaultValue:null,description:"When true the scroll view bounces vertically when it reaches the end\neven if the content is smaller than the scroll view itself. The default\nvalue is false when `horizontal={true}` and true otherwise.",name:"alwaysBounceVertical",required:!1,type:{name:"boolean"}},automaticallyAdjustContentInsets:{defaultValue:null,description:"Controls whether iOS should automatically adjust the content inset for scroll views that are placed behind a navigation bar or tab bar/ toolbar.\nThe default value is true.",name:"automaticallyAdjustContentInsets",required:!1,type:{name:"boolean"}},bounces:{defaultValue:null,description:"When true the scroll view bounces when it reaches the end of the\ncontent if the content is larger then the scroll view along the axis of\nthe scroll direction. When false it disables all bouncing even if\nthe `alwaysBounce*` props are true. The default value is true.",name:"bounces",required:!1,type:{name:"boolean"}},bouncesZoom:{defaultValue:null,description:"When true gestures can drive zoom past min/max and the zoom will animate\nto the min/max value at gesture end otherwise the zoom will not exceed\nthe limits.",name:"bouncesZoom",required:!1,type:{name:"boolean"}},canCancelContentTouches:{defaultValue:null,description:"When false once tracking starts won't try to drag if the touch moves.\nThe default value is true.",name:"canCancelContentTouches",required:!1,type:{name:"boolean"}},centerContent:{defaultValue:null,description:"When true the scroll view automatically centers the content when the\ncontent is smaller than the scroll view bounds; when the content is\nlarger than the scroll view this property has no effect. The default\nvalue is false.",name:"centerContent",required:!1,type:{name:"boolean"}},contentInset:{defaultValue:null,description:"The amount by which the scroll view content is inset from the edges of the scroll view.\nDefaults to {0, 0, 0, 0}.",name:"contentInset",required:!1,type:{name:"Insets"}},contentOffset:{defaultValue:null,description:"Used to manually set the starting scroll offset.\nThe default value is {x: 0, y: 0}",name:"contentOffset",required:!1,type:{name:"PointPropType"}},contentInsetAdjustmentBehavior:{defaultValue:null,description:"This property specifies how the safe area insets are used to modify the content area of the scroll view.\nThe default value of this property must be 'automatic'. But the default value is 'never' until RN@0.51.",name:"contentInsetAdjustmentBehavior",required:!1,type:{name:'"always" | "never" | "automatic" | "scrollableAxes"'}},decelerationRate:{defaultValue:null,description:"A floating-point number that determines how quickly the scroll view\ndecelerates after the user lifts their finger. Reasonable choices include\n   - Normal: 0.998 (the default)\n   - Fast: 0.9",name:"decelerationRate",required:!1,type:{name:'number | "fast" | "normal"'}},directionalLockEnabled:{defaultValue:null,description:"When true the ScrollView will try to lock to only vertical or horizontal\nscrolling while dragging.  The default value is false.",name:"directionalLockEnabled",required:!1,type:{name:"boolean"}},indicatorStyle:{defaultValue:null,description:"The style of the scroll indicators.\n- default (the default), same as black.\n- black, scroll indicator is black. This style is good against\n   a white content background.\n- white, scroll indicator is white. This style is good against\n   a black content background.",name:"indicatorStyle",required:!1,type:{name:'"default" | "black" | "white"'}},maximumZoomScale:{defaultValue:null,description:"The maximum allowed zoom scale. The default value is 1.0.",name:"maximumZoomScale",required:!1,type:{name:"number"}},minimumZoomScale:{defaultValue:null,description:"The minimum allowed zoom scale. The default value is 1.0.",name:"minimumZoomScale",required:!1,type:{name:"number"}},onScrollAnimationEnd:{defaultValue:null,description:"Called when a scrolling animation ends.",name:"onScrollAnimationEnd",required:!1,type:{name:"() => void"}},pinchGestureEnabled:{defaultValue:null,description:"When true, ScrollView allows use of pinch gestures to zoom in and out.\nThe default value is true.",name:"pinchGestureEnabled",required:!1,type:{name:"boolean"}},scrollEventThrottle:{defaultValue:null,description:"This controls how often the scroll event will be fired while scrolling (in events per seconds).\nA higher number yields better accuracy for code that is tracking the scroll position,\nbut can lead to scroll performance problems due to the volume of information being send over the bridge.\nThe default value is zero, which means the scroll event will be sent only once each time the view is scrolled.",name:"scrollEventThrottle",required:!1,type:{name:"number"}},scrollIndicatorInsets:{defaultValue:null,description:"The amount by which the scroll view indicators are inset from the edges of the scroll view.\nThis should normally be set to the same value as the contentInset.\nDefaults to {0, 0, 0, 0}.",name:"scrollIndicatorInsets",required:!1,type:{name:"Insets"}},scrollsToTop:{defaultValue:null,description:"When true the scroll view scrolls to top when the status bar is tapped.\nThe default value is true.",name:"scrollsToTop",required:!1,type:{name:"boolean"}},stickyHeaderIndices:{defaultValue:null,description:"An array of child indices determining which children get docked to the\ntop of the screen when scrolling. For example passing\n`stickyHeaderIndices={[0]}` will cause the first child to be fixed to the\ntop of the scroll view. This property is not supported in conjunction\nwith `horizontal={true}`.",name:"stickyHeaderIndices",required:!1,type:{name:"number[]"}},zoomScale:{defaultValue:null,description:"The current scale of the scroll view content. The default value is 1.0.",name:"zoomScale",required:!1,type:{name:"number"}},endFillColor:{defaultValue:null,description:"Sometimes a scrollview takes up more space than its content fills.\nWhen this is the case, this prop will fill the rest of the\nscrollview with a color to avoid setting a background and creating\nunnecessary overdraw. This is an advanced optimization that is not\nneeded in the general case.",name:"endFillColor",required:!1,type:{name:"string"}},scrollPerfTag:{defaultValue:null,description:"Tag used to log scroll performance on this scroll view. Will force\nmomentum events to be turned on (see sendMomentumEvents). This doesn't do\nanything out of the box and you need to implement a custom native\nFpsListener for it to be useful.\n@platform android",name:"scrollPerfTag",required:!1,type:{name:"string"}},overScrollMode:{defaultValue:null,description:"Used to override default value of overScroll mode.\n\n   Possible values:\n     - 'auto' - Default value, allow a user to over-scroll this view only if the content is large enough to meaningfully scroll.\n     - 'always' - Always allow a user to over-scroll this view.\n     - 'never' - Never allow a user to over-scroll this view.",name:"overScrollMode",required:!1,type:{name:'"always" | "never" | "auto"'}},nestedScrollEnabled:{defaultValue:null,description:"Enables nested scrolling for Android API level 21+. Nested scrolling is supported by default on iOS.",name:"nestedScrollEnabled",required:!1,type:{name:"boolean"}},ref:{defaultValue:null,description:"",name:"ref",required:!1,type:{name:"Ref<FlatList<any>>"}},key:{defaultValue:null,description:"",name:"key",required:!1,type:{name:"ReactText"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/SelectList/SelectList.tsx#ForwardRefExoticComponent"]={docgenInfo:ForwardRefExoticComponent.__docgenInfo,name:"ForwardRefExoticComponent",path:"src/components/SelectList/SelectList.tsx#ForwardRefExoticComponent"})}catch(m){}},"./src/components/SelectList/SelectListItem.tsx":function(e,t,n){var i=n("./node_modules/@babel/runtime/helpers/interopRequireWildcard.js"),a=n("./node_modules/@babel/runtime/helpers/interopRequireDefault.js");Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.SelectListItem=void 0;var o=a(n("./node_modules/@babel/runtime/helpers/extends.js")),r=a(n("./node_modules/@babel/runtime/helpers/objectWithoutProperties.js")),l=i(n("./node_modules/react/index.js")),s=n("./src/components/Checkbox/index.ts"),d=n("./src/components/ListItem/index.ts"),u=l.memo(function(e){var t=e.index,n=void 0===t?0:t,i=(e.isDisabled,e.isSelected),a=void 0!==i&&i,u=e.label,c=e.onSelect,h=void 0===c?function(){return null}:c,m=(e.size,e.value),p=(0,r.default)(e,["index","isDisabled","isSelected","label","onSelect","size","value"]);return l.createElement(d.ListItem,(0,o.default)({onPress:function(e){e.preventDefault(),h(m,n,a)},label:u,rightIcon:l.createElement(s.Checkbox,{isInteractive:!1,shape:"circle",isChecked:a})},p))});t.SelectListItem=u;var c=u;t.default=c;try{u.displayName="SelectListItem",u.__docgenInfo={description:"",displayName:"SelectListItem",props:{isDisabled:{defaultValue:null,description:"",name:"isDisabled",required:!1,type:{name:"boolean"}},index:{defaultValue:null,description:"",name:"index",required:!1,type:{name:"number"}},isSelected:{defaultValue:null,description:"",name:"isSelected",required:!1,type:{name:"boolean"}},onSelect:{defaultValue:null,description:"",name:"onSelect",required:!1,type:{name:"(value: string, index: number, isSelected: boolean) => void"}},value:{defaultValue:null,description:"",name:"value",required:!0,type:{name:"string"}},label:{defaultValue:null,description:"",name:"label",required:!0,type:{name:"string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/SelectList/SelectListItem.tsx#SelectListItem"]={docgenInfo:u.__docgenInfo,name:"SelectListItem",path:"src/components/SelectList/SelectListItem.tsx#SelectListItem"})}catch(h){}try{MemoExoticComponent.displayName="MemoExoticComponent",MemoExoticComponent.__docgenInfo={description:"",displayName:"MemoExoticComponent",props:{isDisabled:{defaultValue:null,description:"",name:"isDisabled",required:!1,type:{name:"boolean"}},index:{defaultValue:null,description:"",name:"index",required:!1,type:{name:"number"}},isSelected:{defaultValue:null,description:"",name:"isSelected",required:!1,type:{name:"boolean"}},onSelect:{defaultValue:null,description:"",name:"onSelect",required:!1,type:{name:"(value: string, index: number, isSelected: boolean) => void"}},value:{defaultValue:null,description:"",name:"value",required:!0,type:{name:"string"}},label:{defaultValue:null,description:"",name:"label",required:!0,type:{name:"string"}}}},"undefined"!==typeof STORYBOOK_REACT_CLASSES&&(STORYBOOK_REACT_CLASSES["src/components/SelectList/SelectListItem.tsx#MemoExoticComponent"]={docgenInfo:MemoExoticComponent.__docgenInfo,name:"MemoExoticComponent",path:"src/components/SelectList/SelectListItem.tsx#MemoExoticComponent"})}catch(h){}}}]);
//# sourceMappingURL=4.7aba8e595b8ba48a0e5f.js.map